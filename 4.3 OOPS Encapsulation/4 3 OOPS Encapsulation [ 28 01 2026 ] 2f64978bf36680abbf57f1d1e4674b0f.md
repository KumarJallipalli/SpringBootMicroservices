# 4.3 OOPS Encapsulation [ 28/01/2026 ]

---

## Encapsulation

- `Encapsulation` â†’ Providing Controlled Access to Class Members [ Variables & Methods ]
    - It Provides Security by Hiding the Data
    - It Prevents unauthorized modification of Data and ensure data integrity.
- In Java, Encapsulation is achieved using `private`, Setters & Getters
    - Setter â†’ A Method whose sole purpose is to Set Data [ for Private Instance Variable ]
    - Getter â†’ A Method whose sole purpose is to Get Data [ for Private Instance Variable ]
        - These are Particularly used in Getting & Setting Private Variables of a Class from Another Class
    - `private` â†’ Access Modifier
        - The primary purpose of theÂ `private`Â modifier is to enforce the principle ofÂ [**encapsulation**](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)Â (data hiding) in OOPS
        - It **Restricts the visibility and accessibility of class members [ like Props & Methods ]**
            - Hence, Setters & Getters are used to Access & Modify the Class Members
        - Members declared asÂ `private`Â are accessible only within the same class in which they are declared
            - i.e., They cannot be accessed by other classes in the same package, subclasses, or any other part of the program
    
    <aside>
    ğŸ’¡
    
    The `private` modifier can be applied to:
    
    - **Variables (fields):**Â Hides the internal state of an object.
    - **Methods:**Â Used for internal helper methods that should not be part of the class's public interface.
    - **Constructors:**Â A class with a private constructor cannot be instantiated from outside the class itself, a
        - A common pattern used in the Singleton design pattern to ensure only one instance of the class is created.
    - **Inner Classes:**Â Top-level classes cannot be private, but nested (inner) classes can.
    
    **Inheritance:**Â Private members are not inherited by subclasses, meaning they are completely hidden from child classes
    
    </aside>
    

```java
public class Encapsulation {
    public static void main(String[] args) {
        Stud s1 = new Stud();
        
        s1.setStudentId(15426);
        s1.setStudentName("Ben10");
        
        System.out.println(s1.getStudentId());
        System.out.println(s1.getStudentName());
    }
}

class Stud {
    private int studentId;
    private String studentName;

    void setStudentId(int studentId) {
        studentId = studentId;
    }
    void setStudentName(String studentName) {
        studentName = studentName;
    }

    int getStudentId() {
        return studentId;
    }
    String getStudentName() {
        return  studentName;
    }
}
```

```java
// Output
0
null
```

WHY..?

- The issue is a classic **variable shadowing** problem in Java.
- Inside your setter methods, the **method parameters** [ Local Variables ] have the same names as the **instance variables**:

```java
    void setStudentId(int studentId) {
        studentId = studentId; // âŒ assigns parameter to itself
    }
```

Here, 

- `studentId` refers to the **parameter**, not the class field.
- So youâ€™re basically doing: â€œtake the parameter and assign it back to the parameterâ€
- Hence, the instance variable never changes.

FIX:

```java
    void setStudentId(int studentId) {
        this.studentId = studentId;
    }
```

### Why this code works

- `studentId` â†’ method parameter
- `this.studentId` â†’ class variable

So now the data actually gets stored in the object âœ”ï¸

## this

- `this` â†’ Reference variable which **refers to theÂ current object** [Â within an instance method or constructor ]
- It is automatically available in all non-static contexts
- USES:
    - To differentiate between instance variables and local variables/parameters with the same name â†’ Sol to Shadowing Problem
    - To call another method of the same object
    - To call another constructor within Constructor of same class
        - i.e., To invoke the current class's constructor â†’ constructor chaining
    - To pass the current object as a parameter
    - To return the current class instance from a method
- LIMITATION:
    - TheÂ `this`Â keywordÂ **cannot**Â be used in aÂ **static**Â context (static methods or static blocks)
    - because static members belong to the class itself, not to a specific object instance.

## Constructor

- `Constructor` â†’Â ***special type of method that is used to initialize an object***Â [ during itâ€™s creation ]
- Imp Points:
    - **Same Name as the Class**: A constructor's name must be same as its class name.
    - **No Return Type**: Constructors do not have an explicit return type, not evenÂ `void`.
    - **Automatic Invocation**: It is called/invoked automatically during object creation, i.e., particularly when you use theÂ `new`Â keyword (e.g.,Â `Main myObj = new Main();`).
- Types:
    - **Default Constructor**:
        - If ONLY you do not define any constructor in a class, the Java compiler automatically provides a no-argument default constructor.
        - This constructor initializes instance variables to their default values (e.g.,Â `0`Â forÂ `int`,Â `null`Â for object references,Â `false`Â forÂ `boolean`).
    - **No-Arg Constructor**:
        - A constructor explicitly defined by the programmer that accepts no parameters.
        - This can be used to set user-defined default values.
    - **Parameterized Constructor**:
        - A constructor that accepts one or more parameters. T
        - his allows you to initialize different objects with distinct values at the time of creation.
    - **Copy Constructor (User-Defined)**:
        - Java does not have a built-in copy constructor like C++,
        - but you can create one by writing a constructor that takes an object of the same class as a parameter to copy its data to the new object.

<aside>
ğŸ’¡

NOTE:

- Can constructors be overloaded?
    - YES
    - A class can have multiple constructors with different parameter lists
    - The compiler differentiates them based on the number and types of arguments, invoking the appropriate one when an object is created.
- Can constructors be inherited?
    - Constructors are not members that can be inherited by subclasses, though they can be accessed using theÂ `super`Â keyword from a subclass constructor.
- Can we make constructor private?
    - **Yes** (used in Singleton pattern)
    - Constructors can use access modifiers (e.g.,Â `public`,Â `private`), but CANNOT beÂ `abstract`,Â `static`,Â `final`, orÂ `synchronized`.
- Can constructor be static?
    - NO
- Is constructor mandatory?
    - NO
- An User-Defined Constructor will ALWAYS Override the Default Constructor
    - i.e., if User-Defined Constructor is defined in the Class â†’ Default Constructor will never be used/Invoked
    - if User-Defined Constructor is NOT defined â†’ Default Constructor will be Invoked by JVM/Compiler by default
</aside>